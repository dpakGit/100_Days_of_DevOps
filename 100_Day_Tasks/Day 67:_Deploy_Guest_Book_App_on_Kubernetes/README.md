Guestbook Application: Architectural BreakdownHere is a visual representation of the application's two-tier architecture:+----------------+          +-------------------+          +-------------------+
|   Internet     |          |   Kubernetes      |          |   Redis Master    |
|   (User)       +--------->|   Frontend Service|          |   (Deployment)    |
|                |          |   (NodePort:30009)|          |                   |
+----------------+          +---------+---------+          +---------+---------+
                                      |                               |
                           +----------+----------+         +----------+----------+
                           |   Frontend Pods     |         |    Redis Slaves     |
                           |   (Replicas: 3)     +---+---->|    (Replicas: 2)    |
                           |                     |   |     |                     |
                           +---------------------+   |     +---------------------+
                                    ^                |                |
                                    |                |                |
                       +------------+------------+   +----------------+
                       |   Redis Slave Service   |
                       |      (ClusterIP)        |
                       +-------------------------+
The application is built on a two-tier architecture: a robust back-end for data management and a scalable front-end for user interaction.1. ðŸ’¾ Back-end Tier: Redis DatabaseThe back-end is powered by Redis, configured in a master-slave replication setup to ensure data consistency and high availability.Redis MasterPurpose: This is the primary instance for all write operations.Deployment (redis-master):Replicas: Exactly 1 replica to maintain a single source of truth for all data.Container: Named master-redis-xfusion, using the official redis image.Resource Requests: Allocated 100m CPU and 100Mi memory to ensure stable performance.Port: Exposes port 6379, Redis's default port.Service (redis-master):Purpose: Provides a stable internal DNS endpoint for the slave instances to discover and connect to the master.Redis SlavePurpose: These instances handle all read requests, offloading traffic from the master and providing redundancy.Deployment (redis-slave):Replicas: 2 replicas for high availability and load distribution.Container: Named slave-redis-xfusion, using the gcr.io/google_samples/gb-redisslave:v3 image.Resource Requests: Allocated 100m CPU and 100Mi memory per replica.Environment Variable: The GET_HOSTS_FROM variable is set to dns, a crucial setting that allows the slaves to find the master using its service name rather than a hard-coded IP address.Service (redis-slave):Purpose: Provides a stable internal DNS endpoint for the frontend to connect to the slaves for read operations.2. ðŸ’» Front-end Tier: Guestbook ApplicationThe front-end is the user-facing part of the application, which handles all guestbook entries.Frontend ApplicationPurpose: This is the application that users interact with.Deployment (frontend):Replicas: 3 replicas to ensure the application remains highly available and can handle user traffic.Container: Named php-redis-xfusion, using the gcr.io/google-samples/gb-frontend@sha256:a908df8486ff66f2c4daa0d3d8a2fa09846a1fc8efd65649c0109695c7c5cbff image.Resource Requests: Each container requests 100m CPU and 100Mi memory.Environment Variable: GET_HOSTS_FROM is set to dns, enabling the frontend pods to find and connect to the Redis slaves using their service name.Service (frontend):Purpose: Exposes the front-end application to the outside world.Type: A NodePort service, which makes it accessible on a specific port on every node in the cluster.Ports: Listens on port 80 (standard HTTP) and forwards traffic to the containers' port 80.NodePort: The service is exposed on nodePort: 30009, allowing you to access the application via any node's IP address at this port.
